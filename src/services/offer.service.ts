// offers.service.ts
import { PrismaClient, Prisma } from "@prisma/client";
import type { 
  Offer, 
  OfferType, 
  OfferStatus,
  DiscountType, 
  CreatorType,
} from "@prisma/client";

const prisma = new PrismaClient();

// =========================== 
// TYPES AND INTERFACES
// ===========================

interface CreateOfferDTO {
  title: string;
  description?: string;
  type: OfferType;
  discountType: DiscountType;
  discountValue: number;
  maxDiscountAmount?: number;
  minOrderAmount?: number;
  validFrom: Date;
  validTo?: Date;
  totalUsageLimit?: number;
  userUsageLimit?: number;
  isPublic?: boolean;
  applicableToAll?: boolean;
  bannerImage?: string;
  termsAndConditions?: string;
  priority?: number;
  status?: OfferStatus;
  
  // Targeting
  targetProductIds?: string[];
  targetCategoryIds?: string[];
  targetVendorIds?: string[];
  targetUserIds?: string[];
  
  // Type-specific configs
  countdownConfig?: CountdownOfferConfig;
  voucherConfig?: VoucherOfferConfig;
  buyXGetYConfig?: BuyXGetYOfferConfig;
  stackRuleConfig?: OfferStackRuleConfig;
}

interface CountdownOfferConfig {
  originalPrice?: number;
  flashPrice?: number;
  quantityLimit?: number;
  countdownEnds: Date;
  urgencyText?: string;
  scarcityText?: string;
  showCountdown?: boolean;
}

interface VoucherOfferConfig {
  code?: string;
  isPublic?: boolean;
  requiresCode?: boolean;
  firstTimeOnly?: boolean;
  isAutoGenerated?: boolean;
}

interface BuyXGetYOfferConfig {
  buyProductId: string;
  getProductId: string;
  buyQuantity?: number;
  getQuantity?: number;
}

interface OfferStackRuleConfig {
  canCombineWithOtherOffers?: boolean;
  maxStackCount?: number;
}

interface OfferFilters {
  type?: OfferType;
  status?: OfferStatus;
  isActive?: boolean;
  createdByType?: CreatorType;
  vendorId?: string;
  page?: number;
  limit?: number;
}

interface VendorOfferFilters {
  type?: OfferType;
  status?: OfferStatus;
  isActive?: boolean;
  page?: number;
  limit?: number;
}

interface OrderItemData {
  productId: string;
  quantity: number;
  price: number;
  vendorId?: string;
}

interface OrderValidationData {
  userId: string;
  items: OrderItemData[];
  subtotal: number;
}

// =========================== 
// BASE SERVICE CLASS
// ===========================

abstract class BaseOfferService {
  protected generateSlug(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/(^-|-$)+/g, '');
  }

  protected generateVoucherCode(prefix?: string): string {
    const randomPart = Math.random().toString(36).substring(2, 10).toUpperCase();
    const codePrefix = prefix ? `${prefix.toUpperCase()}_` : '';
    return `${codePrefix}${randomPart}`;
  }

  protected async logOfferActivity(
    offerId: string, 
    action: string, 
    actorId: string, 
    actorType: 'ADMIN' | 'VENDOR' | 'SYSTEM' = 'ADMIN'
  ): Promise<void> {
    try {
      // Only log for admins for now
      if (actorType === 'ADMIN') {
        const logData: Prisma.ActivityLogCreateInput = {
          action: `OFFER_${action}`,
          entity: 'Offer',
          entityId: offerId,
          meta: {
            actorType,
            timestamp: new Date().toISOString()
          },
          user: { connect: { id: actorId } }
        };

        await prisma.activityLog.create({
          data: logData
        });
      } else {
        // Just log to console for vendors
        console.log(`Activity (${actorType}): OFFER_${action} for offer ${offerId}`);
      }
    } catch (error) {
      console.error('Error logging activity:', error);
    }
  }

  protected getOfferIncludes(): Prisma.OfferInclude {
    return {
     createdByUser: {
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        createdAt: true,
        updatedAt: true,
      }
    },
      createdByVendor: { 
      include: { 
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            role: true,
            createdAt: true,
            updatedAt: true,
            // Exclude password
          }
        }
      } 
    },
      targetProducts: { include: { product: true } },
      targetCategories: { include: { category: true } },
      targetVendors: { include: { vendor: { include: { user: true } } } },
      targetUsers: { include: { user: true } },
      countdownConfig: true,
      voucherConfig: true,
      buyXGetYOffer: {
        include: {
          buyProduct: true,
          getProduct: true
        }
      },
      offerStackRules: true,
      usageHistory: { 
        take: 10, 
        orderBy: { usedAt: 'desc' as Prisma.SortOrder },
        include: { user: true } 
      },
      analytics: { take: 5, orderBy: { recordDate: 'desc' as Prisma.SortOrder } }
    };
  }

  protected getVendorOfferIncludes(): Prisma.OfferInclude {
    return {
      targetProducts: { include: { product: true } },
      targetCategories: { include: { category: true } },
      voucherConfig: true,
      countdownConfig: true,
      buyXGetYOffer: {
        include: {
          buyProduct: true,
          getProduct: true
        }
      },
      offerStackRules: true,
      usageHistory: { 
        take: 10, 
        orderBy: { usedAt: 'desc' as Prisma.SortOrder },
        include: { user: { select: { id: true, name: true, email: true } } } 
      }
    };
  }
}

// =========================== 
// ADMIN OFFER MANAGEMENT
// ===========================

class AdminOfferService extends BaseOfferService {
  
  async createOffer(adminId: string, data: CreateOfferDTO): Promise<Offer & any> {
    const slug = this.generateSlug(data.title);
    
    const offerData: Prisma.OfferCreateInput = {
      title: data.title,
      description: data.description,
      slug,
      type: data.type,
      discountType: data.discountType,
      discountValue: data.discountValue,
      maxDiscountAmount: data.maxDiscountAmount,
      minOrderAmount: data.minOrderAmount,
      validFrom: data.validFrom,
      validTo: data.validTo,
      totalUsageLimit: data.totalUsageLimit,
      userUsageLimit: data.userUsageLimit,
      isPublic: data.isPublic ?? true,
      applicableToAll: data.applicableToAll ?? true,
      bannerImage: data.bannerImage,
      termsAndConditions: data.termsAndConditions,
      priority: data.priority ?? 0,
      status: data.status ?? 'PENDING',
      createdByType: 'ADMIN',
      createdByUser: { connect: { id: adminId } },
      isActive: true
    };

    // Handle countdown offer configuration
    if (data.type === 'COUNTDOWN_DEAL' && data.countdownConfig) {
      offerData.countdownConfig = {
        create: {
          originalPrice: data.countdownConfig.originalPrice,
          flashPrice: data.countdownConfig.flashPrice,
          quantityLimit: data.countdownConfig.quantityLimit,
          remainingQty: data.countdownConfig.quantityLimit,
          countdownEnds: data.countdownConfig.countdownEnds,
          showCountdown: data.countdownConfig.showCountdown ?? true,
          urgencyText: data.countdownConfig.urgencyText,
          scarcityText: data.countdownConfig.scarcityText
        }
      };
    }

    // Handle voucher offer configuration
    if (data.type === 'VOUCHER' && data.voucherConfig) {
      offerData.voucherConfig = {
        create: {
          code: data.voucherConfig.code || this.generateVoucherCode('VOUCHER'),
          isPublic: data.voucherConfig.isPublic ?? true,
          requiresCode: data.voucherConfig.requiresCode ?? true,
          firstTimeOnly: data.voucherConfig.firstTimeOnly ?? false,
          isAutoGenerated: data.voucherConfig.isAutoGenerated ?? false
        }
      };
    }

    // Handle Buy X Get Y offer configuration
    if (data.type === 'BUY_X_GET_Y' && data.buyXGetYConfig) {
      offerData.buyXGetYOffer = {
        create: {
          buyProductId: data.buyXGetYConfig.buyProductId,
          getProductId: data.buyXGetYConfig.getProductId,
          buyQuantity: data.buyXGetYConfig.buyQuantity ?? 1,
          getQuantity: data.buyXGetYConfig.getQuantity ?? 1
        }
      };
    }

    // Handle stack rule configuration
    if (data.stackRuleConfig) {
      offerData.offerStackRules = {
        create: {
          canCombineWithOtherOffers: data.stackRuleConfig.canCombineWithOtherOffers ?? false,
          maxStackCount: data.stackRuleConfig.maxStackCount ?? 1
        }
      };
    }

    // Handle targeting relationships
    if (data.targetProductIds && data.targetProductIds.length > 0) {
      offerData.targetProducts = {
        create: data.targetProductIds.map(productId => ({ productId }))
      };
    }

    if (data.targetCategoryIds && data.targetCategoryIds.length > 0) {
      offerData.targetCategories = {
        create: data.targetCategoryIds.map(categoryId => ({ categoryId }))
      };
    }

    if (data.targetVendorIds && data.targetVendorIds.length > 0) {
      offerData.targetVendors = {
        create: data.targetVendorIds.map(vendorId => ({ vendorId }))
      };
    }

    if (data.targetUserIds && data.targetUserIds.length > 0) {
      offerData.targetUsers = {
        create: data.targetUserIds.map(userId => ({ userId }))
      };
    }

    const offer = await prisma.offer.create({
      data: offerData,
      include: this.getOfferIncludes()
    });
    
    await this.logOfferActivity(offer.id, 'CREATED', adminId, 'ADMIN');
    
    return offer;
  }
  
  async getAllOffers(filters: OfferFilters = {}): Promise<(Offer & any)[]> {
    const where: Prisma.OfferWhereInput = {};
    
    if (filters.type) where.type = filters.type;
    if (filters.status) where.status = filters.status;
    if (filters.isActive !== undefined) where.isActive = filters.isActive;
    if (filters.createdByType) where.createdByType = filters.createdByType;
    if (filters.vendorId) where.createdByVendorId = filters.vendorId;
    
    const page = filters.page || 1;
    const limit = filters.limit || 20;
    const skip = (page - 1) * limit;
    
    const offers = await prisma.offer.findMany({
      where,
      include: this.getOfferIncludes(),
      orderBy: { createdAt: 'desc' },
      skip,
      take: limit
    });
    
    return offers;
  }
  
  async createFlashSale(adminId: string, data: {
    title: string;
    productIds: string[];
    originalPrice: number;
    flashPrice: number;
    quantityLimit: number;
    duration: number;
    urgencyText?: string;
  }): Promise<Offer & any> {
    const countdownEnds = new Date();
    countdownEnds.setHours(countdownEnds.getHours() + data.duration);
    
    return this.createOffer(adminId, {
      title: data.title,
      type: 'FLASH_SALE',
      discountType: 'FIXED_AMOUNT',
      discountValue: data.originalPrice - data.flashPrice,
      validFrom: new Date(),
      validTo: countdownEnds,
      totalUsageLimit: data.quantityLimit,
      targetProductIds: data.productIds,
      applicableToAll: false,
      status: 'ACTIVE',
      countdownConfig: {
        originalPrice: data.originalPrice,
        flashPrice: data.flashPrice,
        quantityLimit: data.quantityLimit,
        countdownEnds,
        urgencyText: data.urgencyText || `Sale ends in ${data.duration} hours!`,
        scarcityText: `Only ${data.quantityLimit} items available!`
      }
    });
  }
  
  async createSystemVoucher(adminId: string, data: {
    title: string;
    code: string;
    discountType: DiscountType;
    discountValue: number;
    maxDiscountAmount?: number;
    minOrderAmount?: number;
    validFrom: Date;
    validTo: Date;
    usageLimit?: number;
    userUsageLimit?: number;
    firstTimeOnly?: boolean;
  }): Promise<Offer & any> {
    return this.createOffer(adminId, {
      ...data,
      type: 'VOUCHER',
      applicableToAll: true,
      isPublic: true,
      status: 'APPROVED',
      voucherConfig: {
        code: data.code,
        isPublic: true,
        firstTimeOnly: data.firstTimeOnly || false,
        isAutoGenerated: false
      }
    });
  }
  
  async approveVendorOffer(adminId: string, offerId: string, approved: boolean): Promise<Offer> {
    const offer = await prisma.offer.update({
      where: { id: offerId },
      data: { 
        status: approved ? 'APPROVED' : 'REJECTED',
        isActive: approved 
      }
    });
    
    await this.logOfferActivity(offerId, approved ? 'APPROVED' : 'REJECTED', adminId, 'ADMIN');
    
    return offer;
  }
  
  async getOfferAnalytics(offerId?: string, dateRange?: { start: Date; end: Date }) {
    const where: Prisma.OfferAnalyticsWhereInput = {};
    
    if (offerId) where.offerId = offerId;
    if (dateRange) {
      where.recordDate = {
        gte: dateRange.start,
        lte: dateRange.end
      };
    }
    
    return prisma.offerAnalytics.findMany({
      where,
      include: { offer: true },
      orderBy: { recordDate: 'desc' }
    });
  }

  async getOfferById(offerId: string): Promise<(Offer & any) | null> {
    return prisma.offer.findUnique({
      where: { id: offerId },
      include: this.getOfferIncludes()
    });
  }

  async updateOffer(adminId: string, offerId: string, data: Partial<CreateOfferDTO>): Promise<Offer & any> {
    const updateData: Prisma.OfferUpdateInput = {
      title: data.title,
      description: data.description,
      type: data.type,
      discountType: data.discountType,
      discountValue: data.discountValue,
      maxDiscountAmount: data.maxDiscountAmount,
      minOrderAmount: data.minOrderAmount,
      validFrom: data.validFrom,
      validTo: data.validTo,
      totalUsageLimit: data.totalUsageLimit,
      userUsageLimit: data.userUsageLimit,
      isPublic: data.isPublic,
      applicableToAll: data.applicableToAll,
      bannerImage: data.bannerImage,
      termsAndConditions: data.termsAndConditions,
      priority: data.priority,
      status: data.status,
      updatedAt: new Date()
    };

    // Handle nested updates properly
    if (data.countdownConfig) {
      updateData.countdownConfig = {
        upsert: {
          create: {
            originalPrice: data.countdownConfig.originalPrice,
            flashPrice: data.countdownConfig.flashPrice,
            quantityLimit: data.countdownConfig.quantityLimit,
            remainingQty: data.countdownConfig.quantityLimit,
            countdownEnds: data.countdownConfig.countdownEnds,
            showCountdown: data.countdownConfig.showCountdown ?? true,
            urgencyText: data.countdownConfig.urgencyText,
            scarcityText: data.countdownConfig.scarcityText
          },
          update: {
            originalPrice: data.countdownConfig.originalPrice,
            flashPrice: data.countdownConfig.flashPrice,
            quantityLimit: data.countdownConfig.quantityLimit,
            countdownEnds: data.countdownConfig.countdownEnds,
            showCountdown: data.countdownConfig.showCountdown,
            urgencyText: data.countdownConfig.urgencyText,
            scarcityText: data.countdownConfig.scarcityText
          }
        }
      };
    }

    if (data.voucherConfig) {
      updateData.voucherConfig = {
        upsert: {
          create: {
            code: data.voucherConfig.code || this.generateVoucherCode('VOUCHER'),
            isPublic: data.voucherConfig.isPublic ?? true,
            requiresCode: data.voucherConfig.requiresCode ?? true,
            firstTimeOnly: data.voucherConfig.firstTimeOnly ?? false,
            isAutoGenerated: data.voucherConfig.isAutoGenerated ?? false
          },
          update: {
            code: data.voucherConfig.code,
            isPublic: data.voucherConfig.isPublic,
            requiresCode: data.voucherConfig.requiresCode,
            firstTimeOnly: data.voucherConfig.firstTimeOnly,
            isAutoGenerated: data.voucherConfig.isAutoGenerated
          }
        }
      };
    }

    if (data.buyXGetYConfig) {
      updateData.buyXGetYOffer = {
        upsert: {
          create: {
            buyProductId: data.buyXGetYConfig.buyProductId,
            getProductId: data.buyXGetYConfig.getProductId,
            buyQuantity: data.buyXGetYConfig.buyQuantity ?? 1,
            getQuantity: data.buyXGetYConfig.getQuantity ?? 1
          },
          update: {
            buyProductId: data.buyXGetYConfig.buyProductId,
            getProductId: data.buyXGetYConfig.getProductId,
            buyQuantity: data.buyXGetYConfig.buyQuantity,
            getQuantity: data.buyXGetYConfig.getQuantity
          }
        }
      };
    }

    const offer = await prisma.offer.update({
      where: { id: offerId },
      data: updateData,
      include: this.getOfferIncludes()
    });

    await this.logOfferActivity(offerId, 'UPDATED', adminId, 'ADMIN');
    
    return offer;
  }

  async deleteOffer(adminId: string, offerId: string): Promise<void> {
    await prisma.offer.delete({
      where: { id: offerId }
    });

    await this.logOfferActivity(offerId, 'DELETED', adminId, 'ADMIN');
  }

  /**
   * Get all vendor permissions with vendor details
   */
  async getAllVendorPermissions(filters: {
    vendorId?: string;
    vendorName?: string;
    page?: number;
    limit?: number;
  } = {}): Promise<any[]> {
    const where: Prisma.OfferPermissionWhereInput = {};

    if (filters.vendorId) {
      where.vendorId = filters.vendorId;
    }

    if (filters.vendorName) {
      where.vendor = {
        user: {
          name: {
            contains: filters.vendorName,
            mode: 'insensitive' as Prisma.QueryMode
          }
        }
      };
    }

    const page = filters.page || 1;
    const limit = filters.limit || 20;
    const skip = (page - 1) * limit;

    const permissions = await prisma.offerPermission.findMany({
      where,
      include: {
        vendor: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
              }
            },
            _count: {
              select: {
                createdOffers: {
                  where: { isActive: true }
                }
              }
            }
          }
        }
      },
      orderBy: {
        vendor: {
          user: { name: 'asc' }
        }
      },
      skip,
      take: limit
    });

    return permissions;
  }

  /**
   * Get specific vendor permissions
   */
  async getVendorPermissions(vendorId: string): Promise<any> {
    const permissions = await prisma.offerPermission.findUnique({
      where: { vendorId },
      include: {
        vendor: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
              }
            },
            createdOffers: {
              where: { isActive: true },
              select: {
                id: true,
                title: true,
                type: true,
                status: true,
                currentUsageCount: true,
                createdAt: true
              }
            }
          }
        }
      }
    });

    if (!permissions) {
      return await this.createDefaultPermissions(vendorId);
    }

    return permissions;
  }

 /**
 * Create default permissions for a vendor
 */
private async createDefaultPermissions(vendorId: string): Promise<any> {
  return await prisma.offerPermission.create({
    data: {
      vendorId,
      // Basic permissions with defaults
      canCreateRegular: true,
      canCreateVoucher: true,
      canCreateCountdown: true,
      canCreateFlashSale: false,
      canCreateBuyXGetY: false,
      canCreateFreeShipping: false,
      canCreateBundleDeal: false,
      canCreateSeasonalSale: true,
      canCreateLoyaltyReward: false,
      canCreateReferralBonus: false,
      
      // Global limits
      maxDiscountPercent: 50,
      maxDiscountAmount: 500,
      maxActiveOffers: 10,
      
      requiresApproval: true
    },
    include: {
      vendor: {
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
            }
          },
          // Use the correct relation name
          createdOffers: {
            where: { isActive: true },
            select: {
              id: true,
              title: true,
              type: true,
              status: true,
              currentUsageCount: true,
              createdAt: true
            }
          }
        }
      }
    }
  });
}

/**
 * Update vendor permissions with improved validation
 */
async updateVendorPermissions(
  adminId: string, 
  vendorId: string, 
  data: {
    // Basic offer type permissions
    canCreateRegular?: boolean;
    canCreateVoucher?: boolean;
    canCreateCountdown?: boolean;
    canCreateFlashSale?: boolean;
    canCreateBuyXGetY?: boolean;
    canCreateFreeShipping?: boolean;
    canCreateBundleDeal?: boolean;
    canCreateSeasonalSale?: boolean;
    canCreateLoyaltyReward?: boolean;
    canCreateReferralBonus?: boolean;
    
    // Global limits
    maxDiscountPercent?: number;
    maxDiscountAmount?: number;
    maxActiveOffers?: number;
    
    // Type-specific limits
    maxVouchersPerOffer?: number;
    maxFlashSaleDuration?: number;
    maxBundleItems?: number;
    
    requiresApproval?: boolean;
  }
): Promise<any> {
  // Validate vendor exists
  const vendor = await prisma.vendor.findUnique({
    where: { id: vendorId },
    include: { user: true }
  });

  if (!vendor) {
    throw new Error('Vendor not found');
  }

  // Validate limits
  if (data.maxDiscountPercent && data.maxDiscountPercent > 100) {
    throw new Error('Max discount percent cannot exceed 100%');
  }

  if (data.maxDiscountPercent && data.maxDiscountPercent < 0) {
    throw new Error('Max discount percent cannot be negative');
  }

  if (data.maxActiveOffers && data.maxActiveOffers < 0) {
    throw new Error('Max active offers cannot be negative');
  }

  const permissions = await prisma.offerPermission.upsert({
    where: { vendorId },
    create: {
      vendorId,
      // Basic permissions with defaults
      canCreateRegular: data.canCreateRegular ?? true,
      canCreateVoucher: data.canCreateVoucher ?? true,
      canCreateCountdown: data.canCreateCountdown ?? true,
      canCreateFlashSale: data.canCreateFlashSale ?? false,
      canCreateBuyXGetY: data.canCreateBuyXGetY ?? false,
      canCreateFreeShipping: data.canCreateFreeShipping ?? false,
      canCreateBundleDeal: data.canCreateBundleDeal ?? false,
      canCreateSeasonalSale: data.canCreateSeasonalSale ?? true,
      canCreateLoyaltyReward: data.canCreateLoyaltyReward ?? false,
      canCreateReferralBonus: data.canCreateReferralBonus ?? false,
      
      // Global limits
      maxDiscountPercent: data.maxDiscountPercent ?? 50,
      maxDiscountAmount: data.maxDiscountAmount ?? 500,
      maxActiveOffers: data.maxActiveOffers ?? 10,
      
      // Type-specific limits
      maxVouchersPerOffer: data.maxVouchersPerOffer,
      maxFlashSaleDuration: data.maxFlashSaleDuration,
      maxBundleItems: data.maxBundleItems,
      
      requiresApproval: data.requiresApproval ?? true
    },
    update: {
      // Update all fields that are provided
      ...(data.canCreateRegular !== undefined && { canCreateRegular: data.canCreateRegular }),
      ...(data.canCreateVoucher !== undefined && { canCreateVoucher: data.canCreateVoucher }),
      ...(data.canCreateCountdown !== undefined && { canCreateCountdown: data.canCreateCountdown }),
      ...(data.canCreateFlashSale !== undefined && { canCreateFlashSale: data.canCreateFlashSale }),
      ...(data.canCreateBuyXGetY !== undefined && { canCreateBuyXGetY: data.canCreateBuyXGetY }),
      ...(data.canCreateFreeShipping !== undefined && { canCreateFreeShipping: data.canCreateFreeShipping }),
      ...(data.canCreateBundleDeal !== undefined && { canCreateBundleDeal: data.canCreateBundleDeal }),
      ...(data.canCreateSeasonalSale !== undefined && { canCreateSeasonalSale: data.canCreateSeasonalSale }),
      ...(data.canCreateLoyaltyReward !== undefined && { canCreateLoyaltyReward: data.canCreateLoyaltyReward }),
      ...(data.canCreateReferralBonus !== undefined && { canCreateReferralBonus: data.canCreateReferralBonus }),
      
      ...(data.maxDiscountPercent !== undefined && { maxDiscountPercent: data.maxDiscountPercent }),
      ...(data.maxDiscountAmount !== undefined && { maxDiscountAmount: data.maxDiscountAmount }),
      ...(data.maxActiveOffers !== undefined && { maxActiveOffers: data.maxActiveOffers }),
      
      ...(data.maxVouchersPerOffer !== undefined && { maxVouchersPerOffer: data.maxVouchersPerOffer }),
      ...(data.maxFlashSaleDuration !== undefined && { maxFlashSaleDuration: data.maxFlashSaleDuration }),
      ...(data.maxBundleItems !== undefined && { maxBundleItems: data.maxBundleItems }),
      
      ...(data.requiresApproval !== undefined && { requiresApproval: data.requiresApproval }),
      
      updatedAt: new Date()
    },
    include: {
      vendor: {
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
            }
          },
          createdOffers: {
            where: { isActive: true },
            select: {
              id: true,
              title: true,
              type: true,
              status: true
            }
          }
        }
      }
    }
  });

  await this.logOfferActivity(
    `PERMISSIONS_UPDATED_${vendorId}`, 
    'UPDATED', 
    adminId, 
    'ADMIN'
  );

  return permissions;
}

/**
 * Bulk update vendor permissions with all offer types
 */
async bulkUpdateVendorPermissions(
  adminId: string,
  vendorIds: string[],
  data: {
    // Basic offer type permissions
    canCreateRegular?: boolean;
    canCreateVoucher?: boolean;
    canCreateCountdown?: boolean;
    canCreateFlashSale?: boolean;
    canCreateBuyXGetY?: boolean;
    canCreateFreeShipping?: boolean;
    canCreateBundleDeal?: boolean;
    canCreateSeasonalSale?: boolean;
    canCreateLoyaltyReward?: boolean;
    canCreateReferralBonus?: boolean;
    
    // Global limits
    maxDiscountPercent?: number;
    maxDiscountAmount?: number;
    maxActiveOffers?: number;
    
    // Type-specific limits
    maxVouchersPerOffer?: number;
    maxFlashSaleDuration?: number;
    maxBundleItems?: number;
    
    requiresApproval?: boolean;
  }
): Promise<{ updated: number; failed: Array<{ vendorId: string; error: string }> }> {
  const failed: Array<{ vendorId: string; error: string }> = [];
  let updated = 0;

  // Use Promise.all for better performance with smaller batches
  const batchSize = 10;
  for (let i = 0; i < vendorIds.length; i += batchSize) {
    const batch = vendorIds.slice(i, i + batchSize);
    
    await Promise.all(
      batch.map(async (vendorId) => {
        try {
          await this.updateVendorPermissions(adminId, vendorId, data);
          updated++;
        } catch (error) {
          console.error(`Failed to update permissions for vendor ${vendorId}:`, error);
          failed.push({
            vendorId,
            error: error instanceof Error ? error.message : 'Unknown error'
          });
        }
      })
    );
  }

  return { updated, failed };
}

/**
 * Get vendor permission statistics with enhanced metrics
 */
// async getVendorPermissionStats(): Promise<{
//   totalVendors: number;
//   vendorsWithPermissions: number;
//   permissionCoverage: number;
//   offerTypePermissions: Record<string, number>;
//   requiresApproval: number;
//   averageLimits: {
//     maxDiscountPercent: number;
//     maxDiscountAmount: number;
//     maxActiveOffers: number;
//   };
//   limitDistributions: {
//     maxDiscountPercent: { range: string; count: number }[];
//     maxActiveOffers: { range: string; count: number }[];
//   };
// }> {
//   const totalVendors = await prisma.vendor.count();
//   const vendorsWithPermissions = await prisma.offerPermission.count();
  
//   // Count permissions for each offer type
//   const offerTypePermissions = {
//     canCreateRegular: await prisma.offerPermission.count({ where: { canCreateRegular: true } }),
//     canCreateVoucher: await prisma.offerPermission.count({ where: { canCreateVoucher: true } }),
//     canCreateCountdown: await prisma.offerPermission.count({ where: { canCreateCountdown: true } }),
//     canCreateFlashSale: await prisma.offerPermission.count({ where: { canCreateFlashSale: true } }),
//     canCreateBuyXGetY: await prisma.offerPermission.count({ where: { canCreateBuyXGetY: true } }),
//     canCreateFreeShipping: await prisma.offerPermission.count({ where: { canCreateFreeShipping: true } }),
//     canCreateBundleDeal: await prisma.offerPermission.count({ where: { canCreateBundleDeal: true } }),
//     canCreateSeasonalSale: await prisma.offerPermission.count({ where: { canCreateSeasonalSale: true } }),
//     canCreateLoyaltyReward: await prisma.offerPermission.count({ where: { canCreateLoyaltyReward: true } }),
//     canCreateReferralBonus: await prisma.offerPermission.count({ where: { canCreateReferralBonus: true } }),
//   };
  
//   const approvalRequired = await prisma.offerPermission.count({
//     where: { requiresApproval: true }
//   });

//   const avgLimits = await prisma.offerPermission.aggregate({
//     _avg: {
//       maxDiscountPercent: true,
//       maxDiscountAmount: true,
//       maxActiveOffers: true
//     }
//   });

//   // Get distribution data
//   const discountRanges = [
//     { range: '0-25%', min: 0, max: 25 },
//     { range: '26-50%', min: 26, max: 50 },
//     { range: '51-75%', min: 51, max: 75 },
//     { range: '76-100%', min: 76, max: 100 },
//   ];

//   const discountDistribution = await Promise.all(
//     discountRanges.map(async ({ range, min, max }) => ({
//       range,
//       count: await prisma.offerPermission.count({
//         where: {
//           maxDiscountPercent: {
//             gte: min,
//             lte: max
//           }
//         }
//       })
//     }))
//   );

//   const offerRanges = [
//     { range: '1-5', min: 1, max: 5 },
//     { range: '6-10', min: 6, max: 10 },
//     { range: '11-20', min: 11, max: 20 },
//     { range: '21+', min: 21, max: 1000 },
//   ];

//   const offerDistribution = await Promise.all(
//     offerRanges.map(async ({ range, min, max }) => ({
//       range,
//       count: await prisma.offerPermission.count({
//         where: {
//           maxActiveOffers: {
//             gte: min,
//             lte: max
//           }
//         }
//       })
//     }))
//   );

//   return {
//     totalVendors,
//     vendorsWithPermissions,
//     permissionCoverage: totalVendors > 0 ? (vendorsWithPermissions / totalVendors) * 100 : 0,
//     offerTypePermissions,
//     requiresApproval: approvalRequired,
//     averageLimits: {
//       maxDiscountPercent: avgLimits._avg.maxDiscountPercent || 0,
//       maxDiscountAmount: avgLimits._avg.maxDiscountAmount || 0,
//       maxActiveOffers: avgLimits._avg.maxActiveOffers || 0
//     },
//     limitDistributions: {
//       maxDiscountPercent: discountDistribution,
//       maxActiveOffers: offerDistribution
//     }
//   };
// }
  /**
   * Reset vendor permissions to defaults
   */
 async resetVendorPermissions(adminId: string, vendorId: string): Promise<any> {
  const defaultPermissions = {
    canCreateRegular: true,
    canCreateVoucher: true,
    canCreateCountdown: true,
    canCreateFlashSale: false,
    canCreateBuyXGetY: false,
    canCreateFreeShipping: false,
    canCreateBundleDeal: false,
    canCreateSeasonalSale: true,
    canCreateLoyaltyReward: false,
    canCreateReferralBonus: false,
    maxDiscountPercent: 50,
    maxDiscountAmount: 500,
    maxActiveOffers: 10,
    requiresApproval: true
  };

  return this.updateVendorPermissions(adminId, vendorId, defaultPermissions);
}

  /**
   * Get vendor permission statistics
   */
  async getVendorPermissionStats(): Promise<{
    totalVendors: number;
    vendorsWithPermissions: number;
    canCreateFlashSale: number;
    requiresApproval: number;
    averageMaxDiscount: number;
  }> {
    const totalVendors = await prisma.vendor.count();
    const vendorsWithPermissions = await prisma.offerPermission.count();
    
    const flashSalePermissions = await prisma.offerPermission.count({
      where: { canCreateFlashSale: true }
    });
    
    const approvalRequired = await prisma.offerPermission.count({
      where: { requiresApproval: true }
    });

    const avgDiscountAgg = await prisma.offerPermission.aggregate({
      _avg: {
        maxDiscountPercent: true,
        maxDiscountAmount: true
      }
    });

    return {
      totalVendors,
      vendorsWithPermissions,
      canCreateFlashSale: flashSalePermissions,
      requiresApproval: approvalRequired,
      averageMaxDiscount: avgDiscountAgg._avg.maxDiscountPercent || 0
    };
  }

  /**
   * Search vendors for permission management
   */
  async searchVendorsForPermissions(query: string, limit: number = 10): Promise<any[]> {
    const vendors = await prisma.vendor.findMany({
      where: {
        OR: [
          {
            user: {
              name: {
                contains: query,
                mode: 'insensitive' as Prisma.QueryMode
              }
            }
          },
          {
            user: {
              email: {
                contains: query,
                mode: 'insensitive' as Prisma.QueryMode
              }
            }
          },
          {
            storeName: {
              contains: query,
              mode: 'insensitive' as Prisma.QueryMode
            }
          }
        ]
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          }
        },
        offerPermission: true,
        _count: {
          select: {
            offers: {
              where: { isActive: true }
            }
          }
        }
      },
      take: limit
    });

    return vendors;
  }
}

// =========================== 
// VENDOR OFFER MANAGEMENT
// ===========================

class VendorOfferService extends BaseOfferService {
  
  async checkVendorPermissions(vendorId: string) {
    let permissions = await prisma.offerPermission.findUnique({
      where: { vendorId }
    });
    
    if (!permissions) {
      permissions = await prisma.offerPermission.create({
        data: { vendorId }
      });
    }
    
    return permissions;
  }
  
  async createVendorOffer(vendorId: string, data: CreateOfferDTO): Promise<Offer & any> {
    const permissions = await this.checkVendorPermissions(vendorId);
    
    this.validateVendorOfferData(data, permissions);
    
    const activeOffers = await prisma.offer.count({
      where: {
        createdByVendorId: vendorId,
        isActive: true
      }
    });
    
    if (activeOffers >= permissions.maxActiveOffers) {
      throw new Error(`Maximum active offers limit (${permissions.maxActiveOffers}) reached`);
    }
    
    const slug = this.generateSlug(data.title);
    const offerData: Prisma.OfferCreateInput = {
      title: data.title,
      description: data.description,
      slug,
      type: data.type,
      discountType: data.discountType,
      discountValue: data.discountValue,
      maxDiscountAmount: data.maxDiscountAmount,
      minOrderAmount: data.minOrderAmount,
      validFrom: data.validFrom,
      validTo: data.validTo,
      totalUsageLimit: data.totalUsageLimit,
      userUsageLimit: data.userUsageLimit,
      isPublic: data.isPublic ?? true,
      applicableToAll: data.applicableToAll ?? false,
      bannerImage: data.bannerImage,
      termsAndConditions: data.termsAndConditions,
      priority: data.priority ?? 0,
      status: permissions.requiresApproval ? 'PENDING' : 'APPROVED',
      createdByType: 'VENDOR',
      createdByVendor: { connect: { id: vendorId } },
      isActive: !permissions.requiresApproval
    };

    // Handle voucher configuration for vendors
    if (data.type === 'VOUCHER' && data.voucherConfig) {
      offerData.voucherConfig = {
        create: {
          code: data.voucherConfig.code || this.generateVendorVoucherCode(vendorId),
          isPublic: data.voucherConfig.isPublic ?? true,
          requiresCode: data.voucherConfig.requiresCode ?? true,
          firstTimeOnly: data.voucherConfig.firstTimeOnly ?? false,
          isAutoGenerated: data.voucherConfig.isAutoGenerated ?? true
        }
      };
    }

    // Handle countdown configuration for vendors
    if (data.type === 'COUNTDOWN_DEAL' && data.countdownConfig) {
      offerData.countdownConfig = {
        create: {
          originalPrice: data.countdownConfig.originalPrice,
          flashPrice: data.countdownConfig.flashPrice,
          quantityLimit: data.countdownConfig.quantityLimit,
          remainingQty: data.countdownConfig.quantityLimit,
          countdownEnds: data.countdownConfig.countdownEnds,
          showCountdown: data.countdownConfig.showCountdown ?? true,
          urgencyText: data.countdownConfig.urgencyText,
          scarcityText: data.countdownConfig.scarcityText
        }
      };
    }

    // Handle Buy X Get Y configuration for vendors
    if (data.type === 'BUY_X_GET_Y' && data.buyXGetYConfig) {
      // Verify products belong to vendor
      const products = await prisma.product.findMany({
        where: {
          id: { in: [data.buyXGetYConfig.buyProductId, data.buyXGetYConfig.getProductId] },
          vendorId: vendorId
        },
        select: { id: true }
      });

      if (products.length !== 2) {
        throw new Error('Both products must belong to your vendor account');
      }

      offerData.buyXGetYOffer = {
        create: {
          buyProductId: data.buyXGetYConfig.buyProductId,
          getProductId: data.buyXGetYConfig.getProductId,
          buyQuantity: data.buyXGetYConfig.buyQuantity ?? 1,
          getQuantity: data.buyXGetYConfig.getQuantity ?? 1
        }
      };
    }

    // Handle stack rule configuration
    if (data.stackRuleConfig) {
      offerData.offerStackRules = {
        create: {
          canCombineWithOtherOffers: data.stackRuleConfig.canCombineWithOtherOffers ?? false,
          maxStackCount: data.stackRuleConfig.maxStackCount ?? 1
        }
      };
    }

    // Vendors can only target their own products
    if (data.targetProductIds && data.targetProductIds.length > 0) {
      // Verify that all products belong to the vendor
      const vendorProducts = await prisma.product.findMany({
        where: {
          id: { in: data.targetProductIds },
          vendorId: vendorId
        },
        select: { id: true }
      });

      if (vendorProducts.length !== data.targetProductIds.length) {
        throw new Error('Some products do not belong to your vendor account');
      }

      offerData.targetProducts = {
        create: data.targetProductIds.map(productId => ({ productId }))
      };
    }

    // Vendors can target categories
    if (data.targetCategoryIds && data.targetCategoryIds.length > 0) {
      offerData.targetCategories = {
        create: data.targetCategoryIds.map(categoryId => ({ categoryId }))
      };
    }

    const offer = await prisma.offer.create({
      data: offerData,
      include: this.getVendorOfferIncludes()
    });
    
    await this.logOfferActivity(offer.id, 'CREATED', vendorId, 'VENDOR');
    
    return offer;
  }
  
  async getVendorOffers(vendorId: string, filters: VendorOfferFilters = {}): Promise<(Offer & any)[]> {
    const where: Prisma.OfferWhereInput = {
      createdByVendorId: vendorId
    };
    
    if (filters.type) where.type = filters.type;
    if (filters.status) where.status = filters.status;
    if (filters.isActive !== undefined) where.isActive = filters.isActive;
    
    const page = filters.page || 1;
    const limit = filters.limit || 20;
    const skip = (page - 1) * limit;
    
    return prisma.offer.findMany({
      where,
      include: this.getVendorOfferIncludes(),
      orderBy: { createdAt: 'desc' },
      skip,
      take: limit
    });
  }
  
  async createVendorVoucher(vendorId: string, data: {
    title: string;
    code?: string;
    discountType: DiscountType;
    discountValue: number;
    minOrderAmount?: number;
    validFrom: Date;
    validTo: Date;
    usageLimit?: number;
    userUsageLimit?: number;
    productIds?: string[];
  }): Promise<Offer & any> {
    const permissions = await this.checkVendorPermissions(vendorId);
    
    if (data.discountType === 'PERCENTAGE' && data.discountValue > permissions.maxDiscountPercent) {
      throw new Error(`Discount percentage cannot exceed ${permissions.maxDiscountPercent}%`);
    }
    
    if (data.discountType === 'FIXED_AMOUNT' && data.discountValue > permissions.maxDiscountAmount) {
      throw new Error(`Discount amount cannot exceed ${permissions.maxDiscountAmount}`);
    }
    
    return this.createVendorOffer(vendorId, {
      ...data,
      type: 'VOUCHER',
      totalUsageLimit: data.usageLimit,
      targetProductIds: data.productIds,
      applicableToAll: !data.productIds || data.productIds.length === 0,
      voucherConfig: {
        code: data.code,
        isPublic: true,
        firstTimeOnly: false
      }
    });
  }
  
  async updateVendorOffer(vendorId: string, offerId: string, data: Partial<CreateOfferDTO>): Promise<Offer & any> {
    const offer = await prisma.offer.findFirst({
      where: {
        id: offerId,
        createdByVendorId: vendorId
      }
    });
    
    if (!offer) {
      throw new Error('Offer not found or not owned by vendor');
    }
    
    const permissions = await this.checkVendorPermissions(vendorId);
    
    if (data.discountValue) {
      this.validateVendorOfferData(data as CreateOfferDTO, permissions);
    }
    
    const updateData: Prisma.OfferUpdateInput = {
      title: data.title,
      description: data.description,
      discountType: data.discountType,
      discountValue: data.discountValue,
      maxDiscountAmount: data.maxDiscountAmount,
      minOrderAmount: data.minOrderAmount,
      validFrom: data.validFrom,
      validTo: data.validTo,
      totalUsageLimit: data.totalUsageLimit,
      userUsageLimit: data.userUsageLimit,
      isPublic: data.isPublic,
      bannerImage: data.bannerImage,
      termsAndConditions: data.termsAndConditions,
      updatedAt: new Date()
    };

    // Handle nested updates
    if (data.countdownConfig) {
      updateData.countdownConfig = {
        upsert: {
          create: {
            originalPrice: data.countdownConfig.originalPrice,
            flashPrice: data.countdownConfig.flashPrice,
            quantityLimit: data.countdownConfig.quantityLimit,
            remainingQty: data.countdownConfig.quantityLimit,
            countdownEnds: data.countdownConfig.countdownEnds,
            showCountdown: data.countdownConfig.showCountdown ?? true,
            urgencyText: data.countdownConfig.urgencyText,
            scarcityText: data.countdownConfig.scarcityText
          },
          update: {
            originalPrice: data.countdownConfig.originalPrice,
            flashPrice: data.countdownConfig.flashPrice,
            quantityLimit: data.countdownConfig.quantityLimit,
            countdownEnds: data.countdownConfig.countdownEnds,
            showCountdown: data.countdownConfig.showCountdown,
            urgencyText: data.countdownConfig.urgencyText,
            scarcityText: data.countdownConfig.scarcityText
          }
        }
      };
    }

    if (data.voucherConfig) {
      updateData.voucherConfig = {
        upsert: {
          create: {
            code: data.voucherConfig.code || this.generateVendorVoucherCode(vendorId),
            isPublic: data.voucherConfig.isPublic ?? true,
            requiresCode: data.voucherConfig.requiresCode ?? true,
            firstTimeOnly: data.voucherConfig.firstTimeOnly ?? false,
            isAutoGenerated: data.voucherConfig.isAutoGenerated ?? true
          },
          update: {
            code: data.voucherConfig.code,
            isPublic: data.voucherConfig.isPublic,
            requiresCode: data.voucherConfig.requiresCode,
            firstTimeOnly: data.voucherConfig.firstTimeOnly
          }
        }
      };
    }

    const updatedOffer = await prisma.offer.update({
      where: { id: offerId },
      data: updateData,
      include: this.getVendorOfferIncludes()
    });
    
    await this.logOfferActivity(offerId, 'UPDATED', vendorId, 'VENDOR');
    
    return updatedOffer;
  }
  
  async deactivateVendorOffer(vendorId: string, offerId: string): Promise<Offer & any> {
    return this.updateVendorOffer(vendorId, offerId, { isActive: false } as Partial<CreateOfferDTO>);
  }
  
  async getVendorOfferAnalytics(vendorId: string, offerId?: string) {
    const where: Prisma.OfferAnalyticsWhereInput = {
      offer: { createdByVendorId: vendorId }
    };
    
    if (offerId) where.offerId = offerId;
    
    return prisma.offerAnalytics.findMany({
      where,
      include: { offer: true },
      orderBy: { recordDate: 'desc' }
    });
  }
  
  private validateVendorOfferData(data: CreateOfferDTO, permissions: any): void {
    const canCreate: Record<OfferType, boolean> = {
      'REGULAR_DISCOUNT': permissions.canCreateRegular,
      'VOUCHER': permissions.canCreateVoucher,
      'COUNTDOWN_DEAL': permissions.canCreateCountdown,
      'FLASH_SALE': permissions.canCreateFlashSale,
      'BUY_X_GET_Y': true, // Generally allowed
      'FREE_SHIPPING': true,
      'BUNDLE_DEAL': true,
      'SEASONAL_SALE': permissions.canCreateRegular,
      'LOYALTY_REWARD': false,
      'REFERRAL_BONUS': false
    };
    
    if (!canCreate[data.type]) {
      throw new Error(`Vendor not allowed to create ${data.type} offers`);
    }
    
    if (data.discountType === 'PERCENTAGE' && data.discountValue > permissions.maxDiscountPercent) {
      throw new Error(`Discount percentage cannot exceed ${permissions.maxDiscountPercent}%`);
    }
    
    if (data.discountType === 'FIXED_AMOUNT' && data.discountValue > permissions.maxDiscountAmount) {
      throw new Error(`Discount amount cannot exceed ${permissions.maxDiscountAmount}`);
    }
    
    if (data.targetVendorIds || data.targetUserIds) {
      throw new Error('Vendors cannot create targeted offers for other vendors or specific users');
    }
  }
  
  private generateVendorVoucherCode(vendorId: string): string {
    const vendorPrefix = vendorId.substring(0, 4).toUpperCase();
    return this.generateVoucherCode(vendorPrefix);
  }

  async getVendorOfferById(vendorId: string, offerId: string): Promise<(Offer & any) | null> {
    return prisma.offer.findFirst({
      where: {
        id: offerId,
        createdByVendorId: vendorId
      },
      include: this.getVendorOfferIncludes()
    });
  }
}

// =========================== 
// CUSTOMER OFFER SERVICE
// ===========================

class CustomerOfferService extends BaseOfferService {
  
  async getAvailableOffers(userId: string, filters: {
    type?: OfferType;
    categoryId?: string;
    vendorId?: string;
    page?: number;
    limit?: number;
  } = {}): Promise<(Offer & any)[]> {
    const now = new Date();
    
    const where: Prisma.OfferWhereInput = {
      isActive: true,
      status: 'APPROVED',
      validFrom: { lte: now },
      OR: [
        { validTo: null },
        { validTo: { gte: now } }
      ],
      AND: [
        {
          OR: [
            { isPublic: true },
            { targetUsers: { some: { userId } } }
          ]
        }
      ]
    };
    
    if (filters.type) where.type = filters.type;
    
    if (filters.categoryId) {
      where.OR = [
        { applicableToAll: true },
        { targetCategories: { some: { categoryId: filters.categoryId } } }
      ];
    }
    
    if (filters.vendorId) {
      where.OR = [
        { createdByVendorId: filters.vendorId },
        { targetVendors: { some: { vendorId: filters.vendorId } } }
      ];
    }
    
    const page = filters.page || 1;
    const limit = filters.limit || 20;
    const skip = (page - 1) * limit;
    
    const offers = await prisma.offer.findMany({
      where,
      include: {
        countdownConfig: true,
        voucherConfig: true,
        buyXGetYOffer: {
          include: {
            buyProduct: true,
            getProduct: true
          }
        },
        targetProducts: { include: { product: true } },
        targetCategories: { include: { category: true } },
        createdByVendor: { include: { user: true } }
      },
      orderBy: [
        { priority: 'desc' },
        { createdAt: 'desc' }
      ],
      skip,
      take: limit
    });
    
    return offers;
  }
  
  async applyVoucherCode(userId: string, code: string, orderData: {
    items: OrderItemData[];
    subtotal: number;
    vendorId?: string;
  }) {
    const voucher = await prisma.offer.findFirst({
      where: {
        isActive: true,
        status: 'APPROVED',
        voucherConfig: { code },
        validFrom: { lte: new Date() },
        OR: [
          { validTo: null },
          { validTo: { gte: new Date() } }
        ]
      },
      include: {
        voucherConfig: true,
        targetProducts: true,
        targetCategories: true,
        usageHistory: { where: { userId } }
      }
    });
    
    if (!voucher) {
      throw new Error('Invalid or expired voucher code');
    }
    
    if (voucher.totalUsageLimit && voucher.currentUsageCount >= voucher.totalUsageLimit) {
      throw new Error('Voucher usage limit exceeded');
    }
    
    if (voucher.userUsageLimit && voucher.usageHistory.length >= voucher.userUsageLimit) {
      throw new Error('You have reached the usage limit for this voucher');
    }
    
    if (voucher.minOrderAmount && orderData.subtotal < voucher.minOrderAmount) {
      throw new Error(`Minimum order amount of ${voucher.minOrderAmount} required`);
    }
    
    if (voucher.voucherConfig?.firstTimeOnly) {
      const userOrderCount = await prisma.order.count({
        where: { 
          userId,
          payments: { some: { status: 'PAID' } }
        }
      });
      
      if (userOrderCount > 0) {
        throw new Error('This voucher is only valid for first-time customers');
      }
    }
    
    const applicableItems = this.filterApplicableItems(orderData.items, voucher);
    
    if (applicableItems.length === 0) {
      throw new Error('This voucher is not applicable to any items in your cart');
    }
    
    const discount = this.calculateDiscount(voucher, applicableItems, orderData.subtotal);
    
    return {
      voucher,
      discount,
      applicableItems,
      message: `Voucher applied! You saved ${discount}`
    };
  }
  
  async getActiveCountdownOffers(): Promise<(Offer & any)[]> {
    const now = new Date();
    
    return prisma.offer.findMany({
      where: {
        type: { in: ['COUNTDOWN_DEAL', 'FLASH_SALE'] },
        isActive: true,
        status: 'APPROVED',
        validFrom: { lte: now },
        validTo: { gte: now },
        countdownConfig: {
          countdownEnds: { gte: now }
        }
      },
      include: {
        countdownConfig: true,
        targetProducts: { include: { product: true } }
      },
      orderBy: { countdownConfig: { countdownEnds: 'asc' } }
    });
  }

  async getBuyXGetYOffers(userId: string): Promise<(Offer & any)[]> {
    const now = new Date();
    
    return prisma.offer.findMany({
      where: {
        type: 'BUY_X_GET_Y',
        isActive: true,
        status: 'APPROVED',
        validFrom: { lte: now },
        OR: [
          { validTo: null },
          { validTo: { gte: now } }
        ]
      },
      include: {
        buyXGetYOffer: {
          include: {
            buyProduct: true,
            getProduct: true
          }
        },
        createdByVendor: {
          include: { user: true }
        }
      },
      orderBy: [
        { priority: 'desc' },
        { createdAt: 'desc' }
      ]
    });
  }
  
  private filterApplicableItems(items: OrderItemData[], voucher: any): OrderItemData[] {
    if (voucher.applicableToAll) return items;
    
    return items.filter(item => {
      if (voucher.targetProducts.some((tp: any) => tp.productId === item.productId)) {
        return true;
      }
      
      return false;
    });
  }
  
  private calculateDiscount(voucher: any, applicableItems: OrderItemData[], subtotal: number): number {
    const applicableAmount = applicableItems.reduce((sum, item) => 
      sum + (item.price * item.quantity), 0);
    
    let discount = 0;
    
    switch (voucher.discountType) {
      case 'PERCENTAGE':
        discount = (applicableAmount * voucher.discountValue) / 100;
        if (voucher.maxDiscountAmount) {
          discount = Math.min(discount, voucher.maxDiscountAmount);
        }
        break;
        
      case 'FIXED_AMOUNT':
        discount = Math.min(voucher.discountValue, applicableAmount);
        break;
        
      case 'FREE_SHIPPING':
        discount = 0;
        break;
        
      default:
        discount = 0;
    }
    
    return Math.round(discount * 100) / 100;
  }
}

// =========================== 
// OFFER VALIDATION SERVICE
// ===========================

class OfferValidationService {
  
  async validateOfferForOrder(offerId: string, orderData: OrderValidationData): Promise<{ valid: boolean; offer: Offer & any; discount?: number }> {
    const offer = await prisma.offer.findUnique({
      where: { id: offerId },
      include: {
        targetProducts: true,
        targetCategories: true,
        targetVendors: true,
        targetUsers: true,
        voucherConfig: true,
        countdownConfig: true,
        buyXGetYOffer: {
          include: {
            buyProduct: true,
            getProduct: true
          }
        },
        usageHistory: { where: { userId: orderData.userId } }
      }
    });
    
    if (!offer) {
      throw new Error('Offer not found');
    }
    
    if (!offer.isActive) {
      throw new Error('Offer is not active');
    }

    if (offer.status !== 'APPROVED') {
      throw new Error('Offer is not approved');
    }
    
    const now = new Date();
    if (offer.validFrom > now) {
      throw new Error('Offer is not yet valid');
    }
    
    if (offer.validTo && offer.validTo < now) {
      throw new Error('Offer has expired');
    }
    
    if (offer.totalUsageLimit && offer.currentUsageCount >= offer.totalUsageLimit) {
      throw new Error('Offer usage limit exceeded');
    }
    
    if (offer.userUsageLimit && offer.usageHistory.length >= offer.userUsageLimit) {
      throw new Error('User usage limit exceeded');
    }
    
    if (offer.minOrderAmount && orderData.subtotal < offer.minOrderAmount) {
      throw new Error(`Minimum order amount of ${offer.minOrderAmount} required`);
    }
    
    if (!offer.applicableToAll) {
      const isTargeted = this.checkOfferTargeting(offer, orderData);
      if (!isTargeted) {
        throw new Error('Offer not applicable to current order');
      }
    }
    
    if (offer.type === 'COUNTDOWN_DEAL' && offer.countdownConfig) {
      if (offer.countdownConfig.countdownEnds < now) {
        throw new Error('Countdown offer has ended');
      }
      
      if (offer.countdownConfig.remainingQty !== null && 
          offer.countdownConfig.remainingQty <= 0) {
        throw new Error('Countdown offer is sold out');
      }
    }
    
    const applicableItems = this.filterApplicableItems(orderData.items, offer);
    const discount = this.calculateDiscount(offer, applicableItems, orderData.subtotal);
    
    return { valid: true, offer, discount };
  }
  
  private checkOfferTargeting(offer: any, orderData: OrderValidationData): boolean {
    if (offer.targetUsers.length > 0) {
      const isUserTargeted = offer.targetUsers.some((tu: any) => 
        tu.userId === orderData.userId);
      if (!isUserTargeted) return false;
    }
    
    if (offer.targetProducts.length > 0) {
      const hasTargetedProduct = orderData.items.some((item: OrderItemData) =>
        offer.targetProducts.some((tp: any) => tp.productId === item.productId));
      if (!hasTargetedProduct) return false;
    }
    
    if (offer.targetVendors.length > 0) {
      const vendorIds = orderData.items.map(item => item.vendorId).filter(Boolean);
      const hasTargetedVendor = vendorIds.some((vendorId: string) =>
        offer.targetVendors.some((tv: any) => tv.vendorId === vendorId));
      if (!hasTargetedVendor) return false;
    }
    
    return true;
  }
  
  private filterApplicableItems(items: OrderItemData[], offer: any): OrderItemData[] {
    if (offer.applicableToAll) return items;
    
    return items.filter(item => {
      if (offer.targetProducts.some((tp: any) => tp.productId === item.productId)) {
        return true;
      }
      
      return false;
    });
  }
  
  private calculateDiscount(offer: any, applicableItems: OrderItemData[], subtotal: number): number {
    const applicableAmount = applicableItems.reduce((sum, item) => 
      sum + (item.price * item.quantity), 0);
    
    let discount = 0;
    
    switch (offer.discountType) {
      case 'PERCENTAGE':
        discount = (applicableAmount * offer.discountValue) / 100;
        if (offer.maxDiscountAmount) {
          discount = Math.min(discount, offer.maxDiscountAmount);
        }
        break;
        
      case 'FIXED_AMOUNT':
        discount = Math.min(offer.discountValue, applicableAmount);
        break;
        
      default:
        discount = 0;
    }
    
    return Math.round(discount * 100) / 100;
  }
}

// =========================== 
// OFFER AUTOMATION SERVICE
// ===========================

class OfferAutomationService {
  
  async deactivateExpiredOffers(): Promise<{ deactivated: number }> {
    const now = new Date();
    
    const expiredOffers = await prisma.offer.updateMany({
      where: {
        isActive: true,
        validTo: { lt: now }
      },
      data: {
        isActive: false,
        status: 'EXPIRED'
      }
    });
    
    await prisma.offer.updateMany({
      where: {
        type: { in: ['COUNTDOWN_DEAL', 'FLASH_SALE'] },
        isActive: true,
        countdownConfig: {
          countdownEnds: { lt: now }
        }
      },
      data: {
        isActive: false,
        status: 'EXPIRED'
      }
    });
    
    return { deactivated: expiredOffers.count };
  }
  
  async updateCountdownQuantities(): Promise<void> {
    const activeCountdownOffers = await prisma.countdownOffer.findMany({
      where: {
        offer: { isActive: true, status: 'APPROVED' },
        countdownEnds: { gte: new Date() },
        quantityLimit: { not: null }
      },
      include: { offer: true }
    });
    
    for (const countdownOffer of activeCountdownOffers) {
      const usedQty = await prisma.offerUsage.count({
        where: { offerId: countdownOffer.offerId }
      });
      
      const remainingQty = Math.max(0, (countdownOffer.quantityLimit || 0) - usedQty);
      
      await prisma.countdownOffer.update({
        where: { id: countdownOffer.id },
        data: { remainingQty }
      });
      
      if (remainingQty === 0) {
        await prisma.offer.update({
          where: { id: countdownOffer.offerId },
          data: { 
            isActive: false,
            status: 'EXPIRED'
          }
        });
      }
    }
  }
  
  async generateOfferAnalytics(): Promise<void> {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    yesterday.setHours(0, 0, 0, 0);
    
    const activeOffers = await prisma.offer.findMany({
      where: { isActive: true, status: 'APPROVED' },
      include: {
        usageHistory: {
          where: {
            usedAt: {
              gte: yesterday,
              lt: new Date(yesterday.getTime() + 24 * 60 * 60 * 1000)
            }
          }
        }
      }
    });
    
    for (const offer of activeOffers) {
      const dailyUsage = offer.usageHistory.length;
      const dailyRevenue = offer.usageHistory.reduce((sum, usage) => 
        sum + usage.orderAmount, 0);
      
      await prisma.offerAnalytics.upsert({
        where: {
          offerId_recordDate: {
            offerId: offer.id,
            recordDate: yesterday
          }
        },
        create: {
          offerId: offer.id,
          totalUsage: dailyUsage,
          totalRevenue: dailyRevenue,
          recordDate: yesterday
        },
        update: {
          totalUsage: dailyUsage,
          totalRevenue: dailyRevenue
        }
      });
    }
  }

  async updateOfferStatus(): Promise<{ updated: number }> {
    const now = new Date();
    
    // Activate offers that have reached their validFrom date
    const activatedOffers = await prisma.offer.updateMany({
      where: {
        status: 'APPROVED',
        isActive: false,
        validFrom: { lte: now },
        OR: [
          { validTo: null },
          { validTo: { gte: now } }
        ]
      },
      data: {
        isActive: true,
        status: 'ACTIVE'
      }
    });
    
    return { updated: activatedOffers.count };
  }

  async trackOfferViews(offerId: string): Promise<void> {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    await prisma.offerAnalytics.upsert({
      where: {
        offerId_recordDate: {
          offerId,
          recordDate: today
        }
      },
      create: {
        offerId,
        recordDate: today,
        totalViews: 1
      },
      update: {
        totalViews: {
          increment: 1
        }
      }
    });
  }

  async trackOfferClicks(offerId: string): Promise<void> {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    await prisma.offerAnalytics.upsert({
      where: {
        offerId_recordDate: {
          offerId,
          recordDate: today
        }
      },
      create: {
        offerId,
        recordDate: today,
        totalClicks: 1
      },
      update: {
        totalClicks: {
          increment: 1
        }
      }
    });
  }
}

// =========================== 
// OFFER USAGE SERVICE
// ===========================

class OfferUsageService {
  
  async recordOfferUsage(data: {
    offerId: string;
    userId: string;
    orderId?: number;
    discountApplied: number;
    orderAmount: number;
  }): Promise<void> {
    // Record usage
    await prisma.offerUsage.create({
      data: {
        offerId: data.offerId,
        userId: data.userId,
        orderId: data.orderId,
        discountApplied: data.discountApplied,
        orderAmount: data.orderAmount
      }
    });

    // Update offer usage count
    await prisma.offer.update({
      where: { id: data.offerId },
      data: {
        currentUsageCount: {
          increment: 1
        }
      }
    });

    // Update countdown quantity if applicable
    const offer = await prisma.offer.findUnique({
      where: { id: data.offerId },
      include: { countdownConfig: true }
    });

    if (offer?.countdownConfig && offer.countdownConfig.remainingQty !== null) {
      await prisma.countdownOffer.update({
        where: { id: offer.countdownConfig.id },
        data: {
          remainingQty: {
            decrement: 1
          }
        }
      });
    }

    // Update analytics
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    await prisma.offerAnalytics.upsert({
      where: {
        offerId_recordDate: {
          offerId: data.offerId,
          recordDate: today
        }
      },
      create: {
        offerId: data.offerId,
        recordDate: today,
        totalUsage: 1,
        totalRevenue: data.orderAmount,
        avgOrderValue: data.orderAmount,
        conversionRate: 0
      },
      update: {
        totalUsage: {
          increment: 1
        },
        totalRevenue: {
          increment: data.orderAmount
        }
      }
    });
  }

  async getUserOfferUsageHistory(userId: string, filters: {
    offerId?: string;
    page?: number;
    limit?: number;
  } = {}): Promise<any[]> {
    const where: Prisma.OfferUsageWhereInput = {
      userId
    };

    if (filters.offerId) {
      where.offerId = filters.offerId;
    }

    const page = filters.page || 1;
    const limit = filters.limit || 20;
    const skip = (page - 1) * limit;

    return prisma.offerUsage.findMany({
      where,
      include: {
        offer: {
          include: {
            voucherConfig: true,
            countdownConfig: true
          }
        },
        order: true
      },
      orderBy: { usedAt: 'desc' },
      skip,
      take: limit
    });
  }

  async getOfferUsageStats(offerId: string): Promise<{
    totalUsage: number;
    uniqueUsers: number;
    totalRevenue: number;
    avgOrderValue: number;
    totalDiscount: number;
  }> {
    const usage = await prisma.offerUsage.findMany({
      where: { offerId }
    });

    const uniqueUsers = new Set(usage.map(u => u.userId)).size;
    const totalRevenue = usage.reduce((sum, u) => sum + u.orderAmount, 0);
    const totalDiscount = usage.reduce((sum, u) => sum + u.discountApplied, 0);
    const avgOrderValue = usage.length > 0 ? totalRevenue / usage.length : 0;

    return {
      totalUsage: usage.length,
      uniqueUsers,
      totalRevenue,
      avgOrderValue,
      totalDiscount
    };
  }
}

// =========================== 
// OFFER REPORTING SERVICE
// ===========================

class OfferReportingService {
  
  async getOfferPerformanceReport(filters: {
    startDate?: Date;
    endDate?: Date;
    offerType?: OfferType;
    vendorId?: string;
  } = {}): Promise<any[]> {
    const where: Prisma.OfferWhereInput = {};

    if (filters.offerType) {
      where.type = filters.offerType;
    }

    if (filters.vendorId) {
      where.createdByVendorId = filters.vendorId;
    }

    const offers = await prisma.offer.findMany({
      where,
      include: {
        usageHistory: {
          where: {
            usedAt: {
              gte: filters.startDate,
              lte: filters.endDate
            }
          }
        },
        analytics: {
          where: {
            recordDate: {
              gte: filters.startDate,
              lte: filters.endDate
            }
          }
        },
        createdByVendor: {
          include: { user: true }
        }
      }
    });

    return offers.map(offer => {
      const totalUsage = offer.usageHistory.length;
      const totalRevenue = offer.usageHistory.reduce((sum, u) => sum + u.orderAmount, 0);
      const totalDiscount = offer.usageHistory.reduce((sum, u) => sum + u.discountApplied, 0);
      const totalViews = offer.analytics.reduce((sum, a) => sum + a.totalViews, 0);
      const totalClicks = offer.analytics.reduce((sum, a) => sum + a.totalClicks, 0);
      const conversionRate = totalClicks > 0 ? (totalUsage / totalClicks) * 100 : 0;

      return {
        id: offer.id,
        title: offer.title,
        type: offer.type,
        status: offer.status,
        createdBy: offer.createdByVendor?.user?.name || 'Admin',
        totalUsage,
        totalRevenue,
        totalDiscount,
        totalViews,
        totalClicks,
        conversionRate: Math.round(conversionRate * 100) / 100,
        avgOrderValue: totalUsage > 0 ? totalRevenue / totalUsage : 0,
        roi: totalRevenue > 0 ? ((totalRevenue - totalDiscount) / totalRevenue) * 100 : 0
      };
    });
  }

  async getVendorOffersSummary(vendorId: string): Promise<{
    totalOffers: number;
    activeOffers: number;
    pendingOffers: number;
    approvedOffers: number;
    rejectedOffers: number;
    totalUsage: number;
    totalRevenue: number;
    totalDiscount: number;
  }> {
    const totalOffers = await prisma.offer.count({
      where: { createdByVendorId: vendorId }
    });

    const activeOffers = await prisma.offer.count({
      where: { createdByVendorId: vendorId, isActive: true }
    });

    const pendingOffers = await prisma.offer.count({
      where: { createdByVendorId: vendorId, status: 'PENDING' }
    });

    const approvedOffers = await prisma.offer.count({
      where: { createdByVendorId: vendorId, status: 'APPROVED' }
    });

    const rejectedOffers = await prisma.offer.count({
      where: { createdByVendorId: vendorId, status: 'REJECTED' }
    });

    const usageData = await prisma.offerUsage.findMany({
      where: {
        offer: { createdByVendorId: vendorId }
      }
    });

    const totalUsage = usageData.length;
    const totalRevenue = usageData.reduce((sum, u) => sum + u.orderAmount, 0);
    const totalDiscount = usageData.reduce((sum, u) => sum + u.discountApplied, 0);

    return {
      totalOffers,
      activeOffers,
      pendingOffers,
      approvedOffers,
      rejectedOffers,
      totalUsage,
      totalRevenue,
      totalDiscount
    };
  }

  async getTopPerformingOffers(filters: {
    limit?: number;
    vendorId?: string;
    startDate?: Date;
    endDate?: Date;
  } = {}): Promise<any[]> {
    const where: Prisma.OfferWhereInput = {
      isActive: true,
      status: 'APPROVED'
    };

    if (filters.vendorId) {
      where.createdByVendorId = filters.vendorId;
    }

    const offers = await prisma.offer.findMany({
      where,
      include: {
        usageHistory: {
          where: {
            usedAt: {
              gte: filters.startDate,
              lte: filters.endDate
            }
          }
        }
      },
      take: filters.limit || 10
    });

    const offerStats = offers.map(offer => {
      const totalUsage = offer.usageHistory.length;
      const totalRevenue = offer.usageHistory.reduce((sum, u) => sum + u.orderAmount, 0);
      const totalDiscount = offer.usageHistory.reduce((sum, u) => sum + u.discountApplied, 0);

      return {
        id: offer.id,
        title: offer.title,
        type: offer.type,
        totalUsage,
        totalRevenue,
        totalDiscount,
        avgOrderValue: totalUsage > 0 ? totalRevenue / totalUsage : 0
      };
    });

    return offerStats.sort((a, b) => b.totalRevenue - a.totalRevenue);
  }

  async getOfferTypeDistribution(vendorId?: string): Promise<Record<OfferType, number>> {
    const where: Prisma.OfferWhereInput = {};

    if (vendorId) {
      where.createdByVendorId = vendorId;
    }

    const offers = await prisma.offer.groupBy({
      by: ['type'],
      where,
      _count: {
        id: true
      }
    });

    const distribution: Record<string, number> = {};
    offers.forEach(item => {
      distribution[item.type] = item._count.id;
    });

    return distribution as Record<OfferType, number>;
  }
}

// =========================== 
// EXPORT SERVICES
// ===========================

export {
  AdminOfferService,
  VendorOfferService,
  CustomerOfferService,
  OfferValidationService,
  OfferAutomationService,
  OfferUsageService,
  OfferReportingService
};

export type {
  CreateOfferDTO,
  OfferFilters,
  VendorOfferFilters,
  OrderItemData,
  OrderValidationData,
  CountdownOfferConfig,
  VoucherOfferConfig,
  BuyXGetYOfferConfig,
  OfferStackRuleConfig
};